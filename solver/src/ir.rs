//! The Datalog Intermediate Representation (IR).
//!
//! This module defines the core data structures used by the planner and the
//! bottom-up engine, representing rules and literals in a way that is
//! decoupled from the top-down solver's `StatementTmpl` format.

use pod2::middleware::{Predicate, StatementTmplArg};

/// Identifies a predicate in the Datalog IR. This includes user-defined
/// custom predicates, built-in native predicates, and planner-generated
/// magic predicates.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum PredicateIdentifier {
    /// A standard predicate (native or custom).
    Normal(Predicate),
    /// A "magic" predicate generated by the planner.
    /// The string is the name of the original predicate, and the `Vec<usize>`
    /// indicates which argument positions are bound in the adornment.
    Magic {
        name: String,
        bound_indices: Vec<usize>,
    },
}

/// A single atom in a Datalog rule, equivalent to a StatementTmpl, like `P(x, y)`.
/// A Datalog purist might call this a "literal", but we're using the term
/// "atom" to avoid confusion with the `Literal` type in the `StatementTmpl`
/// format.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Atom {
    /// Index of this atom in the original list of statement templates when the
    /// custom predicate was defined.  This is used solely for proof
    /// reconstruction: the planner may reorder `body` for evaluation, but we
    /// still need to emit operations in author-written order.  Synthetic or
    /// planner-generated atoms (magic guards, etc.) use `usize::MAX`.
    pub order: usize,
    pub predicate: PredicateIdentifier,
    pub terms: Vec<StatementTmplArg>,
}

// impl fmt::Debug for Atom {
//     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
//         match &self.predicate {
//             PredicateIdentifier::Normal(Predicate::Native(p)) => write!(f, "{:?}", p),
//             PredicateIdentifier::Normal(Predicate::Custom(p)) => {
//                 write!(f, "{}", p.predicate().name)
//             }
//             PredicateIdentifier::Normal(Predicate::BatchSelf(p)) => write!(f, "BatchSelf({})", p),
//             PredicateIdentifier::Magic {
//                 name,
//                 bound_indices,
//             } => write!(f, "{}", name),
//         }
//     }
// }

/// A Datalog rule, consisting of a head and a body. `head :- body`.
#[derive(Debug, Clone)]
pub struct Rule {
    pub head: Atom,
    pub body: Vec<Atom>,
}
