{"version":3,"file":"index.d.ts","names":["Hash","Statement","ValueRef","CustomPredicateRef","Value","AnchoredKey","RawValue","Array","Dictionary","Set","Key","StatementTmplArg","Wildcard","Predicate","NativePredicate","PodData","SignedPod","MainPod","SchemaContainer","PodInfo","SpaceInfo","Params","VDSet","CustomPredicateBatch","CustomPredicate","StatementTmpl","data: any"],"sources":["../generated/types/pod2.d.ts","../src/index.ts"],"sourcesContent":["/* eslint-disable */\n/**\n * This file was automatically generated by json-schema-to-typescript.\n * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,\n * and run json-schema-to-typescript to regenerate this file.\n */\n\nexport type Hash = string;\n/**\n * Type encapsulating statements with their associated arguments.\n */\nexport type Statement =\n  | {\n      predicate: \"None\";\n    }\n  | {\n      /**\n       * @minItems 2\n       * @maxItems 2\n       */\n      args: [ValueRef, ValueRef];\n      predicate: \"Equal\";\n    }\n  | {\n      /**\n       * @minItems 2\n       * @maxItems 2\n       */\n      args: [ValueRef, ValueRef];\n      predicate: \"NotEqual\";\n    }\n  | {\n      /**\n       * @minItems 2\n       * @maxItems 2\n       */\n      args: [ValueRef, ValueRef];\n      predicate: \"LtEq\";\n    }\n  | {\n      /**\n       * @minItems 2\n       * @maxItems 2\n       */\n      args: [ValueRef, ValueRef];\n      predicate: \"Lt\";\n    }\n  | {\n      /**\n       * @minItems 3\n       * @maxItems 3\n       */\n      args: [ValueRef, ValueRef, ValueRef];\n      predicate: \"Contains\";\n    }\n  | {\n      /**\n       * @minItems 2\n       * @maxItems 2\n       */\n      args: [ValueRef, ValueRef];\n      predicate: \"NotContains\";\n    }\n  | {\n      /**\n       * @minItems 3\n       * @maxItems 3\n       */\n      args: [ValueRef, ValueRef, ValueRef];\n      predicate: \"SumOf\";\n    }\n  | {\n      /**\n       * @minItems 3\n       * @maxItems 3\n       */\n      args: [ValueRef, ValueRef, ValueRef];\n      predicate: \"ProductOf\";\n    }\n  | {\n      /**\n       * @minItems 3\n       * @maxItems 3\n       */\n      args: [ValueRef, ValueRef, ValueRef];\n      predicate: \"MaxOf\";\n    }\n  | {\n      /**\n       * @minItems 3\n       * @maxItems 3\n       */\n      args: [ValueRef, ValueRef, ValueRef];\n      predicate: \"HashOf\";\n    }\n  | {\n      /**\n       * @minItems 2\n       * @maxItems 2\n       */\n      args: [CustomPredicateRef, Value[]];\n      predicate: \"Custom\";\n    };\nexport type ValueRef =\n  | {\n      type: \"Literal\";\n      value: Value;\n    }\n  | {\n      type: \"Key\";\n      value: AnchoredKey;\n    };\n/**\n * Represents various POD value types. Array, String, and Bool variants are represented untagged in JSON.\n */\nexport type Value =\n  | {\n      /**\n       * An i64 represented as a string.\n       */\n      Int: string;\n    }\n  | {\n      Raw: RawValue;\n    }\n  | {\n      PublicKey: string;\n    }\n  | Array\n  | Dictionary\n  | string\n  | Set\n  | boolean;\nexport type RawValue = string;\nexport type Key = string;\nexport type StatementTmplArg =\n  | {\n      type: \"None\";\n    }\n  | {\n      type: \"Literal\";\n      value: Value;\n    }\n  | {\n      type: \"AnchoredKey\";\n      /**\n       * @minItems 2\n       * @maxItems 2\n       */\n      value: [Wildcard, Key];\n    }\n  | {\n      type: \"Wildcard\";\n      value: Wildcard;\n    };\nexport type Predicate =\n  | {\n      type: \"Native\";\n      value: NativePredicate;\n    }\n  | {\n      type: \"BatchSelf\";\n      value: number;\n    }\n  | {\n      type: \"Custom\";\n      value: CustomPredicateRef;\n    };\nexport type NativePredicate =\n  | \"None\"\n  | \"False\"\n  | \"Equal\"\n  | \"NotEqual\"\n  | \"LtEq\"\n  | \"Lt\"\n  | \"Contains\"\n  | \"NotContains\"\n  | \"SumOf\"\n  | \"ProductOf\"\n  | \"MaxOf\"\n  | \"HashOf\"\n  | \"DictContains\"\n  | \"DictNotContains\"\n  | \"SetContains\"\n  | \"SetNotContains\"\n  | \"ArrayContains\"\n  | \"GtEq\"\n  | \"Gt\";\nexport type PodData =\n  | {\n      pod_data_payload: SignedPod;\n      pod_data_variant: \"Signed\";\n    }\n  | {\n      pod_data_payload: MainPod;\n      pod_data_variant: \"Main\";\n    };\n\nexport interface SchemaContainer {\n  mainpod: MainPod;\n  pod_info: PodInfo;\n  signedpod: SignedPod;\n  space_info: SpaceInfo;\n}\nexport interface MainPod {\n  data: unknown;\n  id: Hash;\n  params: Params;\n  /**\n   * @minItems 2\n   * @maxItems 2\n   */\n  podType: [number, string];\n  publicStatements: Statement[];\n  vdSet: VDSet;\n}\n/**\n * Params: non dynamic parameters that define the circuit.\n */\nexport interface Params {\n  maxCustomBatchSize: number;\n  maxCustomPredicateArity: number;\n  maxCustomPredicateBatches: number;\n  maxCustomPredicateVerifications: number;\n  maxCustomPredicateWildcards: number;\n  maxDepthMtContainers: number;\n  maxDepthMtVds: number;\n  maxInputPodsPublicStatements: number;\n  maxInputRecursivePods: number;\n  maxInputSignedPods: number;\n  maxMerkleProofsContainers: number;\n  maxOperationArgs: number;\n  maxPublicStatements: number;\n  maxSignedPodValues: number;\n  maxStatementArgs: number;\n  maxStatements: number;\n  numPublicStatementsId: number;\n}\n/**\n * Array: the elements are placed at the value field of each leaf, and the key field is just the array index (integer). leaf.key=i leaf.value=original_value\n */\nexport interface Array {\n  array: Value[];\n  max_depth: number;\n}\n/**\n * Dictionary: the user original keys and values are hashed to be used in the leaf. leaf.key=hash(original_key) leaf.value=hash(original_value)\n */\nexport interface Dictionary {\n  kvs: {\n    [k: string]: Value;\n  };\n  max_depth: number;\n}\n/**\n * Set: the value field of the leaf is unused, and the key contains the hash of the element. leaf.key=hash(original_value) leaf.value=0\n */\nexport interface Set {\n  max_depth: number;\n  set: Value[];\n}\nexport interface AnchoredKey {\n  key: Key;\n  podId: Hash;\n}\nexport interface CustomPredicateRef {\n  batch: CustomPredicateBatch;\n  index: number;\n}\nexport interface CustomPredicateBatch {\n  id: Hash;\n  name: string;\n  predicates: CustomPredicate[];\n}\n/**\n * NOTE: fields are not public (outside of crate) to enforce the struct instantiation through the `::and/or` methods, which performs checks on the values.\n */\nexport interface CustomPredicate {\n  argsLen: number;\n  /**\n   * true for \"and\", false for \"or\"\n   */\n  conjunction: boolean;\n  name: string;\n  statements: StatementTmpl[];\n  /**\n   * Names of the wildcards, the first `args_len` entries correspond to the `args_len` arguments of the custom predicate.\n   */\n  wildcardNames: string[];\n}\n/**\n * Statement Template for a Custom Predicate\n */\nexport interface StatementTmpl {\n  args: StatementTmplArg[];\n  pred: Predicate;\n}\nexport interface Wildcard {\n  index: number;\n  name: string;\n}\n/**\n * VDSet is the set of the allowed verifier_data hashes. When proving a MainPod, the circuit will enforce that all the used verifier_datas for verifying the recursive proofs of previous PODs appears in the VDSet. The VDSet struct that allows to get the specific merkle proofs for the given verifier_data.\n */\nexport interface VDSet {\n  tree_depth: number;\n  vds_hashes: Hash[];\n}\nexport interface PodInfo {\n  created_at: string;\n  data: PodData;\n  id: string;\n  label?: string | null;\n  pod_type: string;\n  space: string;\n}\nexport interface SignedPod {\n  data: unknown;\n  entries: {\n    [k: string]: Value;\n  };\n  id: Hash;\n  /**\n   * @minItems 2\n   * @maxItems 2\n   */\n  podType: [number, string];\n}\nexport interface SpaceInfo {\n  created_at: string;\n  id: string;\n}\n"],"mappings":"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"}