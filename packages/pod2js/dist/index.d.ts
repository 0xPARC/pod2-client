import { Ajv2019 } from "ajv/dist/2019.js";

//#region generated/types/pod2.d.ts

/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
type Hash = string;
/**
 * Type encapsulating statements with their associated arguments.
 */
type Statement = {
  predicate: "None";
} | {
  /**
   * @minItems 2
   * @maxItems 2
   */
  args: [ValueRef, ValueRef];
  predicate: "Equal";
} | {
  /**
   * @minItems 2
   * @maxItems 2
   */
  args: [ValueRef, ValueRef];
  predicate: "NotEqual";
} | {
  /**
   * @minItems 2
   * @maxItems 2
   */
  args: [ValueRef, ValueRef];
  predicate: "LtEq";
} | {
  /**
   * @minItems 2
   * @maxItems 2
   */
  args: [ValueRef, ValueRef];
  predicate: "Lt";
} | {
  /**
   * @minItems 3
   * @maxItems 3
   */
  args: [ValueRef, ValueRef, ValueRef];
  predicate: "Contains";
} | {
  /**
   * @minItems 2
   * @maxItems 2
   */
  args: [ValueRef, ValueRef];
  predicate: "NotContains";
} | {
  /**
   * @minItems 3
   * @maxItems 3
   */
  args: [ValueRef, ValueRef, ValueRef];
  predicate: "SumOf";
} | {
  /**
   * @minItems 3
   * @maxItems 3
   */
  args: [ValueRef, ValueRef, ValueRef];
  predicate: "ProductOf";
} | {
  /**
   * @minItems 3
   * @maxItems 3
   */
  args: [ValueRef, ValueRef, ValueRef];
  predicate: "MaxOf";
} | {
  /**
   * @minItems 3
   * @maxItems 3
   */
  args: [ValueRef, ValueRef, ValueRef];
  predicate: "HashOf";
} | {
  /**
   * @minItems 2
   * @maxItems 2
   */
  args: [CustomPredicateRef, Value[]];
  predicate: "Custom";
};
type ValueRef = {
  type: "Literal";
  value: Value;
} | {
  type: "Key";
  value: AnchoredKey;
};
/**
 * Represents various POD value types. Array, String, and Bool variants are represented untagged in JSON.
 */
type Value = {
  /**
   * An i64 represented as a string.
   */
  Int: string;
} | {
  Raw: RawValue;
} | {
  PublicKey: string;
} | Array | Dictionary | string | Set | boolean;
type RawValue = string;
type Key = string;
type StatementTmplArg = {
  type: "None";
} | {
  type: "Literal";
  value: Value;
} | {
  type: "AnchoredKey";
  /**
   * @minItems 2
   * @maxItems 2
   */
  value: [Wildcard, Key];
} | {
  type: "Wildcard";
  value: Wildcard;
};
type Predicate = {
  type: "Native";
  value: NativePredicate;
} | {
  type: "BatchSelf";
  value: number;
} | {
  type: "Custom";
  value: CustomPredicateRef;
};
type NativePredicate = "None" | "False" | "Equal" | "NotEqual" | "LtEq" | "Lt" | "Contains" | "NotContains" | "SumOf" | "ProductOf" | "MaxOf" | "HashOf" | "DictContains" | "DictNotContains" | "SetContains" | "SetNotContains" | "ArrayContains" | "GtEq" | "Gt";
type PodData = {
  pod_data_payload: SignedPod;
  pod_data_variant: "Signed";
} | {
  pod_data_payload: MainPod;
  pod_data_variant: "Main";
};
interface SchemaContainer {
  mainpod: MainPod;
  pod_info: PodInfo;
  signedpod: SignedPod;
  space_info: SpaceInfo;
}
interface MainPod {
  data: unknown;
  id: Hash;
  params: Params;
  /**
   * @minItems 2
   * @maxItems 2
   */
  podType: [number, string];
  publicStatements: Statement[];
  vdSet: VDSet;
}
/**
 * Params: non dynamic parameters that define the circuit.
 */
interface Params {
  maxCustomBatchSize: number;
  maxCustomPredicateArity: number;
  maxCustomPredicateBatches: number;
  maxCustomPredicateVerifications: number;
  maxCustomPredicateWildcards: number;
  maxDepthMtContainers: number;
  maxDepthMtVds: number;
  maxInputPodsPublicStatements: number;
  maxInputRecursivePods: number;
  maxInputSignedPods: number;
  maxMerkleProofsContainers: number;
  maxOperationArgs: number;
  maxPublicStatements: number;
  maxSignedPodValues: number;
  maxStatementArgs: number;
  maxStatements: number;
  numPublicStatementsId: number;
}
/**
 * Array: the elements are placed at the value field of each leaf, and the key field is just the array index (integer). leaf.key=i leaf.value=original_value
 */
interface Array {
  array: Value[];
  max_depth: number;
}
/**
 * Dictionary: the user original keys and values are hashed to be used in the leaf. leaf.key=hash(original_key) leaf.value=hash(original_value)
 */
interface Dictionary {
  kvs: {
    [k: string]: Value;
  };
  max_depth: number;
}
/**
 * Set: the value field of the leaf is unused, and the key contains the hash of the element. leaf.key=hash(original_value) leaf.value=0
 */
interface Set {
  max_depth: number;
  set: Value[];
}
interface AnchoredKey {
  key: Key;
  podId: Hash;
}
interface CustomPredicateRef {
  batch: CustomPredicateBatch;
  index: number;
}
interface CustomPredicateBatch {
  id: Hash;
  name: string;
  predicates: CustomPredicate[];
}
/**
 * NOTE: fields are not public (outside of crate) to enforce the struct instantiation through the `::and/or` methods, which performs checks on the values.
 */
interface CustomPredicate {
  argsLen: number;
  /**
   * true for "and", false for "or"
   */
  conjunction: boolean;
  name: string;
  statements: StatementTmpl[];
  /**
   * Names of the wildcards, the first `args_len` entries correspond to the `args_len` arguments of the custom predicate.
   */
  wildcardNames: string[];
}
/**
 * Statement Template for a Custom Predicate
 */
interface StatementTmpl {
  args: StatementTmplArg[];
  pred: Predicate;
}
interface Wildcard {
  index: number;
  name: string;
}
/**
 * VDSet is the set of the allowed verifier_data hashes. When proving a MainPod, the circuit will enforce that all the used verifier_datas for verifying the recursive proofs of previous PODs appears in the VDSet. The VDSet struct that allows to get the specific merkle proofs for the given verifier_data.
 */
interface VDSet {
  tree_depth: number;
  vds_hashes: Hash[];
}
interface PodInfo {
  created_at: string;
  data: PodData;
  id: string;
  label?: string | null;
  pod_type: string;
  space: string;
}
interface SignedPod {
  data: unknown;
  entries: {
    [k: string]: Value;
  };
  id: Hash;
  /**
   * @minItems 2
   * @maxItems 2
   */
  podType: [number, string];
}
interface SpaceInfo {
  created_at: string;
  id: string;
}
//#endregion
//#region src/index.d.ts
type Result<T> = {
  success: true;
  pod: T;
} | {
  success: false;
  errors: Ajv2019["errors"];
};
declare function validateMainPod(data: any): Result<MainPod>;
declare function validateSignedPod(data: any): Result<SignedPod>;
//#endregion
export { AnchoredKey, Array, CustomPredicate, CustomPredicateBatch, CustomPredicateRef, Dictionary, Hash, Key, MainPod, NativePredicate, Params, PodData, PodInfo, Predicate, RawValue, SchemaContainer, Set, SignedPod, SpaceInfo, Statement, StatementTmpl, StatementTmplArg, VDSet, Value, ValueRef, Wildcard, validateMainPod, validateSignedPod };
//# sourceMappingURL=index.d.ts.map