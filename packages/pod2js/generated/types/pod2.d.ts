/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Type encapsulating statements with their associated arguments.
 */
export type Statement =
  | {
      predicate: "None";
    }
  | {
      /**
       * @minItems 2
       * @maxItems 2
       */
      args: [ValueRef, ValueRef];
      predicate: "Equal";
    }
  | {
      /**
       * @minItems 2
       * @maxItems 2
       */
      args: [ValueRef, ValueRef];
      predicate: "NotEqual";
    }
  | {
      /**
       * @minItems 2
       * @maxItems 2
       */
      args: [ValueRef, ValueRef];
      predicate: "LtEq";
    }
  | {
      /**
       * @minItems 2
       * @maxItems 2
       */
      args: [ValueRef, ValueRef];
      predicate: "Lt";
    }
  | {
      /**
       * @minItems 3
       * @maxItems 3
       */
      args: [ValueRef, ValueRef, ValueRef];
      predicate: "Contains";
    }
  | {
      /**
       * @minItems 2
       * @maxItems 2
       */
      args: [ValueRef, ValueRef];
      predicate: "NotContains";
    }
  | {
      /**
       * @minItems 3
       * @maxItems 3
       */
      args: [ValueRef, ValueRef, ValueRef];
      predicate: "SumOf";
    }
  | {
      /**
       * @minItems 3
       * @maxItems 3
       */
      args: [ValueRef, ValueRef, ValueRef];
      predicate: "ProductOf";
    }
  | {
      /**
       * @minItems 3
       * @maxItems 3
       */
      args: [ValueRef, ValueRef, ValueRef];
      predicate: "MaxOf";
    }
  | {
      /**
       * @minItems 3
       * @maxItems 3
       */
      args: [ValueRef, ValueRef, ValueRef];
      predicate: "HashOf";
    }
  | {
      /**
       * @minItems 2
       * @maxItems 2
       */
      args: [ValueRef, ValueRef];
      predicate: "PublicKeyOf";
    }
  | {
      /**
       * @minItems 2
       * @maxItems 2
       */
      args: [ValueRef, ValueRef];
      predicate: "SignedBy";
    }
  | {
      /**
       * @minItems 4
       * @maxItems 4
       */
      args: [ValueRef, ValueRef, ValueRef, ValueRef];
      predicate: "ContainerInsert";
    }
  | {
      /**
       * @minItems 4
       * @maxItems 4
       */
      args: [ValueRef, ValueRef, ValueRef, ValueRef];
      predicate: "ContainerUpdate";
    }
  | {
      /**
       * @minItems 3
       * @maxItems 3
       */
      args: [ValueRef, ValueRef, ValueRef];
      predicate: "ContainerDelete";
    }
  | {
      /**
       * @minItems 2
       * @maxItems 2
       */
      args: [CustomPredicateRef, Value[]];
      predicate: "Custom";
    }
  | {
      /**
       * @minItems 2
       * @maxItems 2
       */
      args: [IntroPredicateRef, Value[]];
      predicate: "Intro";
    };
export type ValueRef =
  | {
      type: "Literal";
      value: Value;
    }
  | {
      type: "Key";
      value: AnchoredKey;
    };
/**
 * Represents various POD value types. Array, String, and Bool variants are represented untagged in JSON.
 */
export type Value =
  | {
      Root: Hash;
    }
  | {
      /**
       * An i64 represented as a string.
       */
      Int: string;
    }
  | {
      Raw: RawValue;
    }
  | {
      PublicKey: string;
    }
  | {
      SecretKey: string;
    }
  | Array
  | Dictionary
  | string
  | Set
  | boolean;
export type Hash = string;
export type RawValue = string;
export type Key = string;
export type StatementTmplArg =
  | {
      type: "None";
    }
  | {
      type: "Literal";
      value: Value;
    }
  | {
      type: "AnchoredKey";
      /**
       * @minItems 2
       * @maxItems 2
       */
      value: [Wildcard, Key];
    }
  | {
      type: "Wildcard";
      value: Wildcard;
    };
export type Predicate =
  | {
      type: "Native";
      value: NativePredicate;
    }
  | {
      type: "BatchSelf";
      value: number;
    }
  | {
      type: "Custom";
      value: CustomPredicateRef;
    }
  | {
      type: "Intro";
      value: IntroPredicateRef;
    };
export type NativePredicate =
  | "None"
  | "False"
  | "Equal"
  | "NotEqual"
  | "LtEq"
  | "Lt"
  | "Contains"
  | "NotContains"
  | "SumOf"
  | "ProductOf"
  | "MaxOf"
  | "HashOf"
  | "PublicKeyOf"
  | "SignedBy"
  | "ContainerInsert"
  | "ContainerUpdate"
  | "ContainerDelete"
  | "DictContains"
  | "DictNotContains"
  | "SetContains"
  | "SetNotContains"
  | "ArrayContains"
  | "GtEq"
  | "Gt"
  | "DictInsert"
  | "DictUpdate"
  | "DictDelete"
  | "SetInsert"
  | "SetDelete"
  | "ArrayUpdate";
export type PodData =
  | {
      pod_data_payload: SignedDict;
      pod_data_variant: "Signed";
    }
  | {
      pod_data_payload: MainPod;
      pod_data_variant: "Main";
    };
export type Point = string;
export type Signature = string;

export interface JsonTypes {
  main_pod: MainPod;
  pod_info: PodInfo;
  signed_dict: SignedDict;
  space_info: SpaceInfo;
}
export interface MainPod {
  data: unknown;
  params: Params;
  /**
   * @minItems 2
   * @maxItems 2
   */
  podType: [number, string];
  publicStatements: Statement[];
  stsHash: Hash;
  vdSet: VDSet;
}
/**
 * Params: non dynamic parameters that define the circuit.
 */
export interface Params {
  maxCustomBatchSize: number;
  maxCustomPredicateArity: number;
  maxCustomPredicateBatches: number;
  maxCustomPredicateVerifications: number;
  maxCustomPredicateWildcards: number;
  maxDepthMtContainers: number;
  maxDepthMtVds: number;
  maxInputPods: number;
  maxInputPodsPublicStatements: number;
  maxMerkleProofsContainers: number;
  maxMerkleTreeStateTransitionProofsContainers: number;
  maxOperationArgs: number;
  maxPublicKeyOf: number;
  maxPublicStatements: number;
  maxSignedBy: number;
  maxStatementArgs: number;
  maxStatements: number;
  numPublicStatementsHash: number;
}
/**
 * Array: the elements are placed at the value field of each leaf, and the key field is just the array index (integer). leaf.key=i leaf.value=original_value
 */
export interface Array {
  array: Value[];
  max_depth: number;
}
/**
 * Dictionary: the user original keys and values are hashed to be used in the leaf. leaf.key=hash(original_key) leaf.value=hash(original_value)
 */
export interface Dictionary {
  kvs: {
    [k: string]: Value;
  };
  max_depth: number;
}
/**
 * Set: the value field of the leaf is unused, and the key contains the hash of the element. leaf.key=hash(original_value) leaf.value=0
 */
export interface Set {
  max_depth: number;
  set: Value[];
}
export interface AnchoredKey {
  key: Key;
  root: Hash;
}
export interface CustomPredicateRef {
  batch: CustomPredicateBatch;
  index: number;
}
export interface CustomPredicateBatch {
  id: Hash;
  name: string;
  predicates: CustomPredicate[];
}
/**
 * NOTE: fields are not public (outside of crate) to enforce the struct instantiation through the `::and/or` methods, which performs checks on the values.
 */
export interface CustomPredicate {
  argsLen: number;
  /**
   * true for "and", false for "or"
   */
  conjunction: boolean;
  name: string;
  statements: StatementTmpl[];
  /**
   * Names of the wildcards, the first `args_len` entries correspond to the `args_len` arguments of the custom predicate.
   */
  wildcardNames: string[];
}
/**
 * Statement Template for a Custom Predicate
 */
export interface StatementTmpl {
  args: StatementTmplArg[];
  pred: Predicate;
}
export interface Wildcard {
  index: number;
  name: string;
}
export interface IntroPredicateRef {
  args_len: number;
  name: string;
  verifier_data_hash: Hash;
}
/**
 * VDSet is the set of the allowed verifier_data hashes. When proving a MainPod, the circuit will enforce that all the used verifier_datas for verifying the recursive proofs of previous PODs appears in the VDSet. The VDSet struct that allows to get the specific merkle proofs for the given verifier_data.
 */
export interface VDSet {
  tree_depth: number;
  vds_hashes: Hash[];
}
export interface PodInfo {
  created_at: string;
  data: PodData;
  id: string;
  label?: string | null;
  pod_type: string;
  space: string;
}
export interface SignedDict {
  dict: Dictionary;
  public_key: Point;
  signature: Signature;
}
export interface SpaceInfo {
  created_at: string;
  id: string;
}
