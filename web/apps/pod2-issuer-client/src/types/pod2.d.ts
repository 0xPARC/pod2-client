/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Type encapsulating statements with their associated arguments.
 */
export type Statement =
  | {
      predicate: "None";
    }
  | {
      /**
       * @minItems 2
       * @maxItems 2
       */
      args: [AnchoredKey, Value];
      predicate: "ValueOf";
    }
  | {
      /**
       * @minItems 2
       * @maxItems 2
       */
      args: [AnchoredKey, AnchoredKey];
      predicate: "Equal";
    }
  | {
      /**
       * @minItems 2
       * @maxItems 2
       */
      args: [AnchoredKey, AnchoredKey];
      predicate: "NotEqual";
    }
  | {
      /**
       * @minItems 2
       * @maxItems 2
       */
      args: [AnchoredKey, AnchoredKey];
      predicate: "Gt";
    }
  | {
      /**
       * @minItems 2
       * @maxItems 2
       */
      args: [AnchoredKey, AnchoredKey];
      predicate: "Lt";
    }
  | {
      /**
       * @minItems 3
       * @maxItems 3
       */
      args: [AnchoredKey, AnchoredKey, AnchoredKey];
      predicate: "Contains";
    }
  | {
      /**
       * @minItems 2
       * @maxItems 2
       */
      args: [AnchoredKey, AnchoredKey];
      predicate: "NotContains";
    }
  | {
      /**
       * @minItems 3
       * @maxItems 3
       */
      args: [AnchoredKey, AnchoredKey, AnchoredKey];
      predicate: "SumOf";
    }
  | {
      /**
       * @minItems 3
       * @maxItems 3
       */
      args: [AnchoredKey, AnchoredKey, AnchoredKey];
      predicate: "ProductOf";
    }
  | {
      /**
       * @minItems 3
       * @maxItems 3
       */
      args: [AnchoredKey, AnchoredKey, AnchoredKey];
      predicate: "MaxOf";
    }
  | {
      /**
       * @minItems 2
       * @maxItems 2
       */
      args: [CustomPredicateRef, WildcardValue[]];
      predicate: "Custom";
    };
export type Key = string;
export type Hash = string;
/**
 * Represents various POD value types. Array, String, and Bool variants are represented untagged in JSON.
 */
export type Value =
  | {
      Set: Set;
    }
  | {
      Dictionary: Dictionary;
    }
  | {
      /**
       * An i64 represented as a string.
       */
      Int: string;
    }
  | {
      Raw: RawValue;
    }
  | Array
  | string
  | boolean;
export type Set = Value[];
export type RawValue = string;
export type Array = Value[];
export type StatementTmplArg =
  | {
      type: "None";
    }
  | {
      type: "Literal";
      value: Value;
    }
  | {
      type: "Key";
      /**
       * @minItems 2
       * @maxItems 2
       */
      value: [Wildcard, KeyOrWildcard];
    }
  | {
      type: "WildcardLiteral";
      value: Wildcard;
    };
export type KeyOrWildcard =
  | {
      type: "Key";
      value: Key;
    }
  | {
      type: "Wildcard";
      value: Wildcard;
    };
export type Predicate =
  | {
      type: "Native";
      value: NativePredicate;
    }
  | {
      type: "BatchSelf";
      value: number;
    }
  | {
      type: "Custom";
      value: CustomPredicateRef;
    };
export type NativePredicate =
  | "None"
  | "ValueOf"
  | "Equal"
  | "NotEqual"
  | "Gt"
  | "Lt"
  | "Contains"
  | "NotContains"
  | "SumOf"
  | "ProductOf"
  | "MaxOf"
  | "DictContains"
  | "DictNotContains"
  | "SetContains"
  | "SetNotContains"
  | "ArrayContains";
export type WildcardValue =
  | {
      PodId: Hash;
    }
  | {
      Key: Key;
    };

export interface SchemaContainer {
  mainpod: MainPod;
  signedpod: SignedPod;
}
export interface MainPod {
  podClass: string;
  podType: string;
  proof: string;
  publicStatements: Statement[];
}
export interface AnchoredKey {
  key: Key;
  podId: Hash;
}
export interface Dictionary {
  [k: string]: Value;
}
export interface CustomPredicateRef {
  batch: CustomPredicateBatch;
  index: number;
}
export interface CustomPredicateBatch {
  name: string;
  predicates: CustomPredicate[];
}
/**
 * NOTE: fields are not public (outside of crate) to enforce the struct instantiation through the `::and/or` methods, which performs checks on the values.
 */
export interface CustomPredicate {
  argsLen: number;
  /**
   * true for "and", false for "or"
   */
  conjunction: boolean;
  name: string;
  statements: StatementTmpl[];
}
/**
 * Statement Template for a Custom Predicate
 */
export interface StatementTmpl {
  args: StatementTmplArg[];
  pred: Predicate;
}
export interface Wildcard {
  index: number;
  name: string;
}
export interface SignedPod {
  entries: {
    [k: string]: Value;
  };
  podClass: string;
  podType: string;
  proof: string;
}
